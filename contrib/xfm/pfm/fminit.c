/*
* ---------------------------------------------------------------------------
* This source code is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* If this code is modified and/or redistributed, please retain this
* header, as well as any other 'flower-box' headers, that are
* contained in the code in order to give credit where credit is due.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* Please use this URL to review the GNU General Public License:
* http://www.gnu.org/licenses/gpl.txt
* ---------------------------------------------------------------------------
*/
#include <stdio.h>     
#include <stdlib.h>
#include <fcntl.h>    
#include <ctype.h>   
#include <string.h> 
#include <memory.h>
#include <time.h>

#include "../lib/symtab.h"		/* our utilities/tools */
#include "../afileio/afidefs.h"   


#include "fmconst.h"               /* constant definitons */
#include "rfm_const.h"


#include "fmcmds.h"
#include "fmstruct.h"              /* structure definitions */
#include "fmproto.h"

/*
****************************************************************************
*
*  Mnemonic: FMinit
*  Abstract: This routine opens the initial input file and the output file
*            and does other necessary house keeping chores.
*  Parms:    argc - Number of arguments passed to fm from command line
*            argv - Argument vector list passed from command line
*  Returns:  Valid if all is well, ERROR if system could not be initialized.
*  Date:     17 November 1988
*  Author:   E. Scott Daniels
*
*  Modified:  22 Apr 1991 - To remove need to have dedicated page num buffer
*              3 May 1991 - To initialize flags2 variable
*              3 May 1992 - To convert for post script output
*              7 Nov 1992 - To alloc header font buffers
*             12 Nov 1992 - To add justify PS proc
*             13 Nov 1992 - To allocate current font buffer before use
*             10 Dec 1992 - To use AFIwrite for ansi compat on sun
*              6 Apr 1993 - To create a dummy variable block for psuedo
*                           commands generated by .gm and .gd commands.
*             26 May 1993 - To add stroke command to box routine.
*             13 Jun 1993 - To set the psfm variable by placing a dv command
*                           into the initial input buffer.
*             12 Jul 1993 - To set the def item list font ptr to null
*             21 Feb 1994 - To open output file just "w"
*                           To put out the PS routine rightxy for header/footer
*             22 Feb 1994 - To init figure font (ffont)
*              7 Apr 1994 - To seup for TOC now that linelen is points related
*              7 Oct 2000 - To use new AFI tokeniser
*	      10 Oct 2001 - To add new justification PS functions
*	      13 Jan 2001 - Added sym table support
*		08 Nov 2006 - Some cleanup and now allow default input from stdin.
*		10 Apr 2007 - Memory leak cleanup 
*		16 Sep 2007 - added page geometry argument support
*		13 Nov 2007 - Changed the imbed/run() mechanism to better support the 
*				oneject processing.
*****************************************************************************
*/
int FMinit( int argc, char **argv )
{
	int i;               /* loop index */
	char buf[1024];
	char *ptr;           /* pointer to argument */
	char	*ifname = "stdin";
	char	*ofname = "stdout";
	int 	pageh = 0;
	int 	pagew = 0;

	argc--;
	argv++;
	while( argc > 0 && argv[0][0] == '-' )
	{
		switch( argv[0][1] )
		{
			case 'g': 
				pageh = atoi( argv[1] );
				if( (ptr = strchr( argv[1], 'x' )) != NULL )
					pagew = atoi( ptr + 1 );
				argv++;
				argc--;
				break;

			case 't':
				trace = atoi( argv[1] );
				argv++;
				argc--;
				break;

			case '?':
				FMmsg( ERROR, "Usage: tfm [input-file [output-file [inital command tokens]]]" );
				exit( 1 );

			default:	
				fprintf( stderr, "unrecognised option: %s", argv[0] );
				exit( 1 );
		}	

		argv++;
		argc--;
	}

	if( argc >= 1 )
	{
		if( *argv[0] != '-' )		/* allow - to default to stdin */
			ifname = argv[0];
	}

	if( argc > 1 )
	{
		if( *argv[1] != '-' )		/* allow - to default to stdout */
			ofname = argv[1];
	}

	if( strcmp( ifname, ofname ) == 0 )
	{
		FMmsg( ERROR, "input name cannot be same as output; this is just wrong");
		return ERROR;
	}

	if( FMopen( ifname ) < VALID )       /* open the initial input file */
		return ERROR;                     

	symtab = sym_alloc( 4999 );		/* symtab for variables */
	AFIsettoken( fptr->file, symtab, " \t", '&', '^', ":" );
	AFIsetflag( fptr->file, AFI_F_EOBSIG, AFI_SET );		/* end of buffer notifications */
#ifdef KEEP
this is dropped because imbed now puts a run/stop command into the stream to pop the call to fmrun() at end of file
	AFIsetflag( fptr->file, AFI_F_EOFSIG, AFI_SET );		/* end of file notifications -- must have so .im file .cmd works */
#endif

	ofile = AFIopen( ofname, "w" );      /* open output file */
	if( ofile < VALID )
	{
		FMmsg( E_CANTOPEN, ofname );
		FMclose( );
		return ERROR;
	}

	version = "pfm V2.4/0b137"; 		/* returned by .gv v command */
	snprintf( buf, sizeof( buf ), "+PFM text formatter (%s) started", version );
	FMmsg( -1, buf );

	/* write out our postscript routines that make life easier */
	snprintf( buf, sizeof( buf ), "%%! %s generated this postscript file\n", version );
	AFIwrite( ofile, buf );
	/*AFIwrite( ofile, "%! PFM 1.1-02282 PostScript output\n" );*/
	/*AFIwrite( ofile, "% Copyright (c) 1994-2002 by E. Scott Daniels. All Rights Reserved!\n" );*/
	AFIwrite( ofile, "% A happy programme is one that generates other programmes;\n" );
	AFIwrite( ofile, "% This was generated by a happy programme!\n" );

	/*  new page macro to showpage and set the origion of the 0,0 */
	if( pageh )
	{
		AFIwrite( ofile, "%%BeginSetup\n" );
		AFIwrite( ofile, "[{\n" );
		AFIwrite( ofile, "%BeginFeature: *PageRegion C\n" );
		snprintf( buf, sizeof( buf ), "<</PageSize [%d %d]>> setpagedevice\n", pagew, pageh );
		AFIwrite( ofile, buf );
		AFIwrite( ofile, "%EndFeature\n" );
		AFIwrite( ofile, "} stopped cleartomark\n" );
 		AFIwrite( ofile, "%%EndSetup\n" );
		snprintf( buf, sizeof( buf ), "/xlate {0 %d translate} def\n/newp {showpage xlate} def\n", pageh );
		AFIwrite( ofile, buf );
	}
	else
		AFIwrite( ofile, "/xlate {0 792 translate} def\n/newp {showpage xlate} def\n" );
	
	/* draw a box:  lower left x y upper right x y box */
	AFIwrite( ofile, "/box { 3 index 3 index moveto 3 index 1 index lineto\n" );
	AFIwrite( ofile, "1 index 1 index lineto 1 index 3 index lineto\n" );
	AFIwrite( ofile, "closepath stroke pop pop pop pop } def \n" );

	/* position the text to the right of the page:  x (string) right */
	/* this routine assumes that the current point is established and that the */
	/* current y value is to be used */
	/* AFIwrite( ofile, "/right { dup stringwidth pop 3 -1 roll exch sub\n" ); */
	/* AFIwrite( ofile, "currentpoint exch pop moveto show } def\n" );*/

	/* old things */
	/* position the text to the right of the page: x y (string) rightxy */
	AFIwrite( ofile, "/rightxy { dup stringwidth pop 3 index exch sub 2 index\n" );
	AFIwrite( ofile, "moveto show pop pop } def\n" );

#ifdef KEEP
	/* ------ these are OLD, here for reference only; look further =------- */
	/* center the text:   centerx y (string) cen */
	AFIwrite( ofile, "/cen { dup stringwidth pop 2 div 3 index exch sub\n" );
	AFIwrite( ofile, "2 index moveto show pop pop } def\n" );

	/* justify a line of text: spaces (string) maxx just */
	AFIwrite(ofile, "/just { currentpoint pop 2 index stringwidth pop add sub\n");
	AFIwrite( ofile, "2 index div 0 32 3 index widthshow pop pop } def\n" );
#endif

	/* generic show routine that pops things off the stack and shows them:
		(font) (string) fontsize [(font) (string) fontsize...] n showstack
	*/
	AFIwrite( ofile, "/showstack { np 0 eq { show } { 0 1 np 1 sub { pop /fs exch def exch " );
	AFIwrite( ofile, "findfont fs scalefont setfont " );
	AFIwrite( ofile, "show } for } ifelse } def\n" );

	/* justify text: (font) (string) points [(font) (string) points...] nblanks width(points) ntripples just - */
	AFIwrite( ofile, "%these functions are protected by: Copyright (c) 2001 by E. Scott Daniels. All Rights Reserved!\n" );
	AFIwrite( ofile, "/just { /bc exch def /wid exch def /np exch def " );
	AFIwrite( ofile, "np 0 eq { dup /sw exch stringwidth pop def } " );
	AFIwrite( ofile, "{ /sw 0 def 0 1 np 1 sub { /i exch def dup /fs exch def " );
	AFIwrite( ofile, "i 3 mul 2 add index findfont fs scalefont setfont " );
	AFIwrite( ofile, "i 3 mul 1 add index stringwidth pop " );
	AFIwrite( ofile, "/sw exch sw add def	} for } ifelse\n" );
	/*AFIwrite( ofile, "currentpoint pop sw add	wid exch sub bc div /bs exch def " );*/
	AFIwrite( ofile, "wid sw sub bc div /bs exch def " );
	AFIwrite( ofile, "np 0 eq { bs 0 32 3 index widthshow pop } " );
	AFIwrite( ofile, "{ 0 1 np 1 sub { pop /fs exch def exch findfont fs scalefont setfont ");
	AFIwrite( ofile, "bs 0 32 3 index widthshow pop } for } ifelse } def\n");
	
	/*  center text: (font) (text) textsize [(font) (text) textsize] width n cen - */
	AFIwrite( ofile, "/cent { /np exch def /wid exch def np 0 eq { dup /sw exch stringwidth pop def } ");
	AFIwrite( ofile, "{ /sw 0 def 0 1 np 1 sub { /i exch def dup /fs exch def ");
	AFIwrite( ofile, "i 3 mul 2 add index findfont fs scalefont setfont i 3 mul 1 add index stringwidth pop ");
	AFIwrite( ofile, "/sw exch sw add def } for } ifelse ");
	/*AFIwrite( ofile, "currentpoint pop sw add wid exch sub 2 div 0 rmoveto showstack } def\n"); */
	AFIwrite( ofile, "wid sw sub 2 div 0 rmoveto showstack } def\n" );
	
	/*% right just text: % (font) (text) textsize [(font) (text) textsize] width n right - */
#ifdef KEEP
	/* did not work */
	AFIwrite( ofile, "/right { /np exch def /wid exch def np 0 eq {   % width string 0 1 assumed " );
	AFIwrite( ofile, "dup /sw exch stringwidth pop def } " );
	AFIwrite( ofile, "{ /sw 0 def 0 1 np 1 sub { /i exch def dup /fs exch def " );
	AFIwrite( ofile, "i 3 mul 2 add index findfont fs scalefont setfont i 3 mul 1 add index stringwidth pop " );
	AFIwrite( ofile, "/sw exch sw add def } for } ifelse " );
	AFIwrite( ofile, "currentpoint pop sw add wid exch sub 0 rmoveto showstack } def\n" ); 
#endif


	AFIwrite( ofile, "/right { /np exch def /wid exch def /sw 0 def 0 1 np 1 sub { \n" );
	AFIwrite( ofile, "/i exch def dup /fs exch def i 3 mul 2 add index findfont fs scalefont setfont \n" );
	AFIwrite( ofile, "i 3 mul 1 add index stringwidth pop /sw exch sw add def } for \n" );
	AFIwrite( ofile, " currentpoint exch wid add sw sub exch moveto showstack } def \n" );

	/* normal text output with font setting: % (font) (text) textsize (font) (text) textsize... n splat - */
	AFIwrite( ofile, "/splat { /np exch def showstack } def\n" );

	/* send out the first translate- dont require an immediate .pa from user */
	AFIwrite( ofile, "xlate\n" );

	/* now initialize from a C point of view */

	difont = NULL;     /* initially no def list item font string defined */
	ffont = NULL;      /* no figure font defined */
	textcolour = strdup( "000000" );
	curfont = strdup( DEF_TEXTFONT );
	runfont = strdup( DEF_RUNFONT );
	FMfmt_add( );


	textspace = 2;
	iptr = 0;
	optr = 0;                 /* start at beginning of the output buffer */
	obuf = (char *) malloc( sizeof( char ) * 2048 );
	inbuf = (char *) malloc( sizeof( char ) * 2048 );
	if( ! obuf || ! inbuf )
	{
		fprintf( stderr, "malloc of obuffer failed\n" );
		return ERROR;
	}
	*obuf = (char) 0;

	sprintf( inbuf, ".dv pfm 1 : " );   /* simulate a user command - define compiler name */
	AFIpushtoken( fptr->file, inbuf );  /* and push onto the input stack */

	if( (path = getenv( "PFM_PATH" )) == NULL )
		path = getenv( "XFM_PATH" );

	cur_col = firstcol = (struct col_blk *) malloc( sizeof( struct col_blk ) );
	if( cur_col == NULL )
		return ERROR;

	cur_col->lmar = DEF_LMAR;
	cur_col->width = 550 - DEF_LMAR; /* set single column width */
	cur_col->next = NULL;          /* by default we are in single column mode */
	boty = (11 * 71)-30;

	flags = PARA_NUM;              /* turn on paragraph numbering */


	memset( tocname, 0, sizeof(tocname ) );
	snprintf( tocname, sizeof( tocname )-5, "%s",  ifname );
	if( (ptr = strrchr( tocname, '.' )) != NULL )
		*ptr = 0;
	strcat( tocname, ".toc" );		/* same filename with .toc extension */

	memset( pnum, 0, sizeof( pnum ) );

	for( i = argc - 1; i > 2; i-- )
		AFIpushtoken( fptr->file, argv[i] );	/* whatever is after output file we use as input */


	for( i = 0; i < MAX_HLEVELS; i++ )   /* allocate and init header blks */
	{
		headers[i] = (struct header_blk *) malloc( sizeof( struct header_blk ) );
		if( headers[i] == NULL )
			return ERROR;

		headers[i]->font = (char *) malloc( (strlen( DEF_HEADFONT )) + 1 );
		strcpy( headers[i]->font, DEF_HEADFONT );  /* move in default string */
	
		headers[i]->flags = HTOC;              /* initially only TOC flag set */
		headers[i]->indent = DEF_HEADINDENT;   /* set default indention */
		headers[i]->level = i+1;               /* set the level */
		headers[i]->skip = 21;                  /* skip down 2 lines before/1after */
	}

	headers[0]->size = DEF_H1SIZE;   /* set default header text sizes */
	headers[1]->size = DEF_H2SIZE;
	headers[2]->size = DEF_H3SIZE;
	headers[3]->size = DEF_H4SIZE;
	headers[0]->flags |= HEJECTC+HTOUPPER;   /* header level 1 defaults */

	return VALID;
}
