/*
* ======================================================================== v1.0/0a157 
*                                                         
*       This software is part of the AT&T Ningaui distribution 
*	
*       Copyright (c) 2001-2009 by AT&T Intellectual Property. All rights reserved
*	AT&T and the AT&T logo are trademarks of AT&T Intellectual Property.
*	
*       Ningaui software is licensed under the Common Public
*       License, Version 1.0  by AT&T Intellectual Property.
*                                                                      
*       A copy of the License is available at    
*       http://www.opensource.org/licenses/cpl1.0.txt             
*                                                                      
*       Information and Software Systems Research               
*       AT&T Labs 
*       Florham Park, NJ                            
*	
*	Send questions, comments via email to ningaui_support@research.att.com.
*	
*                                                                      
* ======================================================================== 0a229
*/

/*
 ---------------------------------------------------------------------------
 Mnemonic:	ng_log - Log routines to support Ningaui
 Abstract:	This file contains the various routines that support cross 
		cluster logging. 

 Protocol:	Ng_logd listens for udp messages that are generated by 
		these routines.  It expectes that each message is terminated
		with a newline character. This allows us to send the message
		that is written to the local log file w/o changes.

 Date: 		27 March 20001
 Author:	E. Scott Daniels
 ---------------------------------------------------------------------------
*/

#include	<unistd.h>
#include	<stdarg.h>     /* required for variable arg processing - MUST be included EARLY to avoid ast stdio.h issues */
#include 	<ctype.h>

#include	<errno.h>
#include	<stdlib.h>
#include	<string.h>

#include	<syslog.h>
#include	<time.h>
#include 	<inttypes.h>


#include	<sys/socket.h>         /* network stuff */
#include 	<netinet/in.h>
#include	<net/if.h>
#include	<netdb.h>

/*#include	<ast_common.h>*/
#include	<stdio.h>		/* this comes from ast land and MUST be included AFTER stdarg */
#include 	<sfio.h>


#include	"ningaui.h"
#include	<ng_lib.h>


#define	MAX_LEN	1440			/* we broadcast, so all (plus trunc flag) must fit into payload max size of 1472/1468 depending on system */

extern int 	verbose;

static int	initialised = 0;
static int 	 nfd = -1;		/* file descriptor of udp port */
static int	ack_needed = 2;		/* number of other hosts that must ack the message */
static int	seq = 0;		/* message sequence number */
static int	timeout = 20;		/* max seconds before deciding that nobody heard us */
static struct sockaddr_in *addr = NULL; /* address block we send to */

                                  /* static header info - created once during init */
static char name[1024];           /* process name and pid */

static char *log_str[] = {     /* strings cooresponding to the syslog.h constants */
  "EMERG",
  "ALERT",
  "CRIT",
  "ERROR",
  "WARNING",
  "NOTICE",
  "INFO",
  "DEBUG",
  "USER1",
  "USER2",
  "USER3",
  "USER4",
  "USER5",
  (char *) 0
 };


/* ---------- globals for caller to set ------------------------ */
int ng_log_sync = 0;        /* depricated with sfio, kept for back compat */

static int bail_out = -1;	/* bail if priority is less than this and not enough nacks received */
static char *nack_logf = NULL;	/* log file for when we do not get enough acks back */



static void log_init( )
{
	char *bcast;               /* broadcast address */
	char full_addr[50];        /* full address with port number tacked on */
	char myhost[100];
	char *dport;               /* log daemon port number */
	char *gp;                  /* general work pointer */
	char *ifname;              /* interface name we broadcast over */
	char *p;		   /* general file character */
	char *pname;			/* name of the process invoking us */

	if( (dport = ng_env( "NG_LOGGER_PORT" )) == NULL )
		dport = ng_strdup( "ng_logger;udp" );			/* default to something that might be right */

	if( (gp = ng_env( "LOG_ACK_NEEDED" )) != NULL )
	{
		ack_needed = atoi( gp );                       /* acks that are needed to feel good */
		ng_free( gp );
	}

	if( (gp = ng_env( "LOG_TIMEOUT" )) != NULL )
	{
		timeout = atoi( gp );
		ng_free( gp );
	}

	if( (ifname = ng_env( "LOG_IF_NAME" )) == NULL )
		ifname = ng_strdup( "eth0" );

	if( (gp = ng_env( "LOG_ABORT")) )  		/* if a bailout level is set */
	{
		bail_out = atoi( gp );
		ng_free( gp );
	}

	if( (nack_logf = ng_env( "LOG_NACKLOG" )) == NULL )
		nack_logf = ng_rootnm( LOG_DIR "/ng_log.nack" );
	ng_cbleat( CBLEAT_LIB, 2, "ng_log(lib): nack log is: %s", nack_logf );

	ng_sysname( myhost, sizeof( myhost ) );
	if( (p = strchr( myhost, '.' )) )
		*p = 0;					/* truncate at first dot (ning01 rather than ning01.research...) */

	if( argv0 )
	{
		if( strpbrk( argv0, "([" ) )     		/* shell interface  puts shell's pid in argv0 */
			sprintf( name, "%s %s", myhost, argv0 );   
		else
		{
			if( (pname = strrchr( argv0, '/' )) )
				sfsprintf( name, sizeof(name), "%s %s[%d]", myhost, pname+1, getpid( ) );	/* basename -- relaykc names too long */
			else
				sprintf( name, "%s %s[%d]", myhost, argv0, getpid( ) );   /* use our pid */
		}
	}
	else
		sprintf( name, "%s UNKNOWN[%d]", myhost, getpid( ) );  /* just use ours if none */

	if( ack_needed <= 0 )
	{
		/*	ng_cbleat( CBLEAT_LIB, 1, "broadcast disabled; writing messages directly" );	-- these were too annoying */
		if( dport )
			ng_free( dport );
		if( ifname )
			ng_free( ifname );
		return;				/* not broadcasting */
	}

	if( (nfd = ng_openudp( 0 )) >= 0 )           /* open random udp port */
	{
		if( (bcast = ng_env( "NG_LOG_BCAST" )) == NULL )	/* if supplied we send udp directly and dont broadcast */
			bcast = ng_getbroadcast(  nfd, ifname );	/* else; get the broadcast address from the interface */

		if( bcast )
		{
			if( strchr( bcast, ':' ) || strchr( bcast, ';' ) )
				sfsprintf( full_addr, sizeof( full_addr ), "%s%s", bcast, dport );    /* bcast had a trailing : or ; */
			else
				sfsprintf( full_addr, sizeof( full_addr ), "%s:%s", bcast, dport );    /* bcast not made with trailing : or ; */

			ng_cbleat( CBLEAT_LIB, 1, "ng_log(lib): broadcasting to: %s", full_addr );

			addr = ng_dot2addr( full_addr );
			

			ng_free( bcast );
			initialised = 1;
		}
		else
		{
			ng_cbleat( CBLEAT_ALL, 0, "could not get broadcast address for: %s: %s", ifname, strerror( errno ) );
		}
	}
	else
		perror( "ng_log(lib): unable to open udp port" );

	if( dport )
		ng_free( dport );
	if( ifname )
		ng_free( ifname );
}

/* reinitialise things if we are beyond the reinit waiting period.  Seems that with multiple 
	network addresses aliased to the same interface we 'drop off' from a broadcast perspective.
	if we dont get enough acks, then we shut the nfd and reinitialise.  when done, we set a 
	timer so we wait at least a few minutes before trying the reinit process again 
*/
void ng_log_reinit( )
{
	static ng_timetype	allow_next = 0;		/* when the next reinit is allowed */
	ng_timetype	now;

	if( (now = ng_now( )) > allow_next )
	{
		ng_cbleat( CBLEAT_LIB, 1, "ng_log(lib): reinitialising broadcast interface" );
		allow_next = now + 3000;			/* dont retry for another 5 min */

		if( nfd >= 0 )
			close( nfd );
		nfd = -1;
		initialised = 0;			/* cause a reinit of messages */

		log_init( );
	}
}


/* sends a formatted message.  is public so that a log repeater can invoke with a log message
	that it was sent. If called by a routine outside of this compile, the caller must 
	ensure that the buffer has a trailing newline character as ng_logd expects this.
	if len is 0 then obuf assumed to be null terminated.
*/
int ng_log_bcast( char *obuf, int len, int sn )
{
	int ack_in = 0;
	Sfio_t	*f;
	char	ack_buf[256];	        /* inbound ack/nack messages from daemons */
	char	from[100];		/* address of sender of ack */
	int	s;

	if( ! initialised )
		log_init( );

	if( nfd >= 0 )              /* send out and wait for warm fuzzies from ng_logd processes */
	{
		if( ! len )			/* it must be computed */
			len = strlen( obuf );

		s = ng_write_a_udp( nfd, addr,  obuf, len );    /* send it on the airwaves */
		ng_cbleat( CBLEAT_LIB, 2, "ng_log(lib): broadcast: len=%d s=%d  %s (%s)", len, s, strerror( errno ), obuf );

		while( ack_in < ack_needed  && ng_readudp( nfd, ack_buf, sizeof( ack_buf ), from, timeout ) )
		{
			if( atoi( ack_buf ) == sn )     /* if seq == 10, +10 is good -nn  or +mm is bad */
			{
				ack_in++;
				ng_cbleat( CBLEAT_LIB, 2, "ack received for msg %d from %s", sn, from );
			}
			else
				ng_cbleat( CBLEAT_LIB, 2, "nack or ack for wrong msg: received %d  wanted %d: from %s", atoi( ack_buf ), sn, from );
					
		}

		if( ack_in < ack_needed )		/* write to nack log to be sure of duplication */
		{
			ng_cbleat( CBLEAT_LIB, 2, "ng_log(lib): not enough acks. needed %d, got %d", ack_needed, ack_in );

			if( (f = ng_sfopen( NULL, nack_logf, "a" )) )
			{
				sfprintf( f, "%s", obuf );
				if( sfclose( f ) )
					ng_cbleat( CBLEAT_LIB, 2, "error writing to nak log: %s: %s", nack_logf, strerror( errno ) );
			}

			ng_log_reinit( );			/* reinitialise -- this may help */
		}
	}

	return( ack_in );
}

void ng_alog( int priority, char *logname, char *pristr, char *fmt, ...)
{
	extern char *tzname[2];  /* time zone names from local time */
	static char obuf[4096];		/* bigger than MAX_LEN to allow for <trunc> if we chop it short, and \n\0 in all cases */

	Sfio_t	*f;			/* pointer to nack.log file */
	va_list	argp;			/* pointer at variable arguments */
	/*char	ack_buf[100]; */	        /* inbound ack/nack messages from daemons */
	/*char	from[50];*/		/* ip address of ack/nak daemon */
	char	time[50];		/* time according to ningaui */
	ng_timetype gmt;		/* now in gmt */
	char	*uidx; 			/* index into output buffer for user message */
	char	*lname;			/* pointer to log name string */
	int	freename = 1;		/* need to free the log name buffer */
	char	*s;    			/* pointer into string buffer */
	int	space; 			/* amount of space in obuf for user message */
	int	hlen;  			/* size of header in output buffer */
	int	ack_in = 0;		/* number of ack messages we have */
	int	needed;			/* number of bytes that we neeeded in the dest buffer */


	if( ! initialised )
		log_init( );

	if( ++seq > 9999 )    /* canNOT use a message id of 0! */
		seq = 1;
 
	if( isupper( *logname ) )          /* if 1st char of logname is uppercase, assume env var name */
	{
		if( ! (lname = ng_env( logname )) )                        /* get name from config  */
			if( ! (lname = ng_env( "MASTER_LOG" )) )           /* attempt to get master name */
				if( ! (lname = getenv( "NINGAUI_LOG" )) )  /* get name from environment */
					lname = ng_rootnm( LOG_NAME );		           /* use default if not there */ 
	}
	else                                                /* else assume user supplied filename to use */
	{
		lname = logname;
		freename = 0;			/* assume that user will free if its needed */
	}

 	gmt = ng_now( );                     /* get current gmt */
 	ng_stamptime( gmt, 0, time );        /* format time into ningaui standard */
 
	obuf[1024] = 0;				/* sf does NOT null terminate if we max out */
	if( nfd >= 0 )				/* broadcast message has header: sequence logname;  */
	{
		sfsprintf( obuf, 1023, "%04d %s; %I*u[%s%c] %03d[%s] %s  ", 
				seq, logname, sizeof( gmt ), gmt, time, *tzname[0], priority, pristr, name );
	}
	else
	{
		sfsprintf( obuf, 1023, "%I*u[%s%c] %03d[%s] %s  ", sizeof( gmt ), gmt, time, *tzname[0], priority, pristr, name );
	}

	space = MAX_LEN - strlen( obuf );		/* remaining space for user message */
	hlen = strlen( obuf );          
	uidx = obuf + hlen;		/* point past header stuff */

	va_start( argp, fmt );                       

	if( (needed=vsnprintf( uidx, space, fmt, argp )) >= space )  	/* vsnprintf returns bytes needed for operation */
	{								/* if we get sfio functions we need to ensure that there is a final null*/
		obuf[MAX_LEN] = 0;			/* yes this is NOT MAX_LEN-1 as we allow MAX_LEN bytes before the null */
		strcat( obuf, "<trunc>" );		/* obuf made bigger than MAX_LEN to accomodate this */
		ng_cbleat( CBLEAT_LIB, 1, "ng_log(lib): msg truncated: usr-msg-len=%d  avail-buffer=%d  bytes-chopped=%d msg-len=%d", needed, space, needed-space, strlen( obuf) );
	}

	va_end( argp );                                 /* cleanup of variable arg stuff */

	s = obuf;
	while( (s = strchr( s, '\n' )) )       		/* trash line feeds user may have put in */
		*s = ' ';
	
	s = strchr(obuf, 0);
	if((s == obuf) || (s[-1] != '\n'))        	/* terminate w/ linefeed if needed */
	{
		*s++ = '\n';
		*s = 0;
	}

	ack_in = ng_log_bcast( obuf, 0, seq );		/* zero len causes bcast to calc len */

	if( nfd >= 0 &&  ack_in < ack_needed ) 
	{
	
		if( priority <= bail_out )
		{
			ng_cbleat( CBLEAT_ALL, 0, "ng_log(lib): priority(%d) higher/eq log_abort(%d); exiting", priority, bail_out );
			exit( 99 );
		}
	}

	ng_cbleat( CBLEAT_LIB, 2, "ng_log(lib): local: (%s)", obuf );	 /* we used to do local logging only if ack failed, but now its always */

	if( nfd >= 0 )		/* must skip the broadcast header mess */
	{
		for( s=obuf; *s && *s != ';'; s++ );
		for( s++; *s && *s == ' '; s++ );
	}
	else
		s = obuf;

	if( (f = ng_sfopen( NULL, lname, "a") ) != NULL) 
	{
 		sfwrite( f, s, strlen( s ) );
			if( ng_log_sync )
				fsync( fileno(f) );
			if( sfclose( f ) )
				ng_cbleat( CBLEAT_LIB, 2, "error writing to log: %s: %s", lname, strerror( errno ) );
	} 
	else
		sfprintf( sfstderr, "unable to open log file: (%s)\n", lname );

	if( freename )			/* free if it was allocated */
		ng_free( lname );

}                 /* ng_log */

void ng_log_setack( int n )	/* for testing only */
{
	ack_needed = n;
	ng_cbleat( CBLEAT_ALL, 0, "ack needed forced to: %d", n );
}
/*
* ---------------------------------------------------------------------------
*  Mnemonic: ng_log
*  Abstract: This is the default interface to the master log.
*  Parms:    Priority - Priority of the message
*            fmt      - Sprintf style format string
*             ...     - Parms for vsprintf
*  Returns:  Nohting.
* ---------------------------------------------------------------------------
*/

void ng_log( int priority, char *fmt, ...)
{
	va_list argp;                    /* pointer at variable arguments */
	char ubuf[NG_BUFFER+1];          /* spot to build user message in */
	char *pristr = "UNKNOWN";        /* priority string to pass along */

	if( priority <= LOG_DEBUG+5 && priority >= 0  )
		pristr = log_str[priority];     /* set string if valid */

	va_start( argp, fmt );           /* point to first variable argument */
	vsnprintf( ubuf, NG_BUFFER -1, fmt, argp );     /* format the user message */
	va_end( argp );                  /* cleanup of variable arg stuff */
	 
	ng_alog( priority, "MASTER_LOG", pristr, "%s", ubuf );
}


#ifdef SELF_TEST
main( )
{
	extern int verbose;

	char *buf;
	char lbuf[4096];		/* long buffer to test truncation */
	char *id = "this is a long buffer that should be padded with the character a, and truncated  ";
	Sfio_t *f;
	int count = 0;

	verbose = 0x190;

	log_init( );

	ng_cbleat( CBLEAT_LIB, 1, "defaults: ack_needed=%d timeout=%d", ack_needed, timeout );

	ack_needed=15;			/* force failure */
	ng_log(7, "ng_log() selft test message to test reinit" );
	ng_cbleat( CBLEAT_ALL, 0, "sleeping for 5.5 min to see if we reset things" );
	sleep( 330 );
	ng_cbleat( CBLEAT_LIB, 1, "writing self test msg 2 to see if things were reset" );
	ng_log(7, "ng_log() self test message number two  to test reinit" );
	ng_cbleat( CBLEAT_LIB, 1, "after write: ack_needed=%d timeout=%d", ack_needed, timeout );

	

	ng_log( 7, "%s", "this is another test message -- short [end]" );
	memset( lbuf, 0, sizeof( lbuf ) );		/* build a message that is longer than max-length */
	memset( lbuf, 'a', sizeof( lbuf ) - 2 );
	memcpy( lbuf, id, strlen(id) );
	ng_log( 7, "%s", lbuf );

	verbose = 0;
	sfprintf( sfstderr, "\nenter test message(s) to send; ctl-D to finish\n" );
	f = ng_sfopen( NULL, "/dev/fd/0", "r" );		/* read from standard input and log the text */

	verbose = 9;
	timeout = 7;
	while( buf = sfgetr( f, '\n', SF_STRING ) )
	{
		count++;
		ng_cbleat( CBLEAT_ALL, 0, "sending message via log: (%s)", buf );
		ng_log( 7, "%s %d(count)", buf, count );
	}
}
#endif

/* #--- SELF CONTAINED DOCUMENTATION SECTION -------------------------------
&scd_start
&doc_title(ng_log:Write a message to the Ningaui log (Ningaui C library))

&space
&synop  
	#include <syslog.h> &break
	void ng_log( int priority, char *fmt, ^...); &break
	void ng_alog( int priority, char *logname, char *id, char *fmt, ^...);

&space
&desc	These funcitons provide for standardised logging by a process into 
	an &n log file. Support for both intra-cluster logging (UDP broadcast), 
	inter-cluster logging (UDP to specific host)  and 
	direct logging (straight to file) is provided by these routines.
	Both &ital(ng_log) and &ital(ng_alog) will format the user message with 
	a standardised message header, and cause the message to be written to the 
	appropriate log.
	A message is always written to the local log file, and &this may transmit 
	the message to &lit(ng_logd) on one or more remote machines depending on 
	the seetings of several cartulary variables. The conditions which cause 
	message to be transmitted are described in later sections.
&space
	The user message supplied is appended to a log header which has the syntax: 
&space
&beglitb
	<timestamp>[<humantime><tz>] <priority>[<pstring>] <host> <pname>[<pid>]
&endlitb
&space
	Where:
&begterms
&term	timestamp : Is an integer timestamp as returned by &ital(ng_now).
&term	humantime : Is the timestamp in a human readable format.
&term	tz : Is a single character indicating the timezone of the machine 
	that generated the message. 
&term	priority : Is the message priority that was passed to &ital(ng_log).
&term	pstring : Is the string translation of the priority.
&term	host : Is the name of the host where the message originated. 
&term	pname : Is the name of the programme that is writing the message. 
&term	pid : Is the process id of the process writing the message. 
&endterms
&space
	The user message is supplied via a &ital(printf) style format 
	string, and a variable number of arguments depending on the 
	contents of the format string.  

&space
&subcat	The Master Log File Name
	&ital(Ng_log) will use &lit(ng_env()) to search for the cartulary 
	variable &lit(MASTER_LOG) and use this value if it is defined.
	If &lit(MASTER_LOG) is not defined,
	the UNIX environment is searched, using the &ital(env()) system
	call, and the value of the variable &lig(NINGAUI_LOG) is used 
	as the pathname of the log file.
	If neither variable name is located then  the file 
	&lit(/ningaui/site/log/master) is used.

&space
&subcat The Alternate Log File Name
	&ital(Ng_alog) accepts a buffer that can contain either a Ningaui
	cartulary file variable name, or the filename of the log file
	to use.  If the first character of the buffer is an uppercase 
	character (A-Z) then a Ningaui cartulary file variable name 
	is assumed. The file name associated with this variable is used
	as the name of the log file. If the first character of the buffer
	is &stress(not) an uppercase character, then it is assumed to 
	contain the filename (optionally with path) of the file to open.
	
&space
&subcat Message Length
	A message message size (header and user text) is limited to 1440
	bytes. This limit is currently imposed because we use UDP broadcast
	to spread the messages to all nodes on the cluster and thus the 
	message must fit into a single message. Messages that are too large
	will be truncated and the string "<trunc>" will be added. We purposly
	keep our message shorter than the accepted 1472 byte UDP payload 
	length to be obvious that this is done on purpose. 

.if [ 0 ]
&space
&subcat Forced Synchronisation
	The calling routine can force &ital(ng_log) to synchronise output 
	with the real disk file before returning. This is accomplished 
	by defining the external integer variable &lit(ng_log_sync) and 
	setting it to a non-zero value. 
.fi

&subcat	Broadcasting
	The message is broadcast to all &lit(ng_logd) daemons on the 
	network if the &lit(LOG_ACK_NEEDED) cartulary file 
	variable is greater than zero. Once a message has been 
	broadcast, &this will wait for a specified number of seconds
	for acknowlegements that the message was received by
	&lit(ng_logd) processes. 
	The message that &ital(ng_log) will broadcast to the log daemon
	contains a header followed by the text that the daemon should put 
	into the log. The header has the following syntax:
&break	
&beglitb
	<sequence-token><whitespace><[logpath/]logname>;
&endlitb
&space
	The log daemon is &stress(not) expected to write the broadcast
	header information to the log file.
	The &ital(sequence-token) is to be used when acknowldeging the receipt
	of the message, and the message is to be written to the file 
	described by the second token. A terminating semicolon has 
	been added to allow the log daemon to accept more information 
	in the broadcast header without requiring all processes to 
	send the information.

&subcat	Acknowledgements 
	Log daemons are expected to acknowledge the receipt and successful
	addition of the message to the log file. The acknowledgement is 
	to consist of a message that has the syntax:
	{+|-}<sequence-token>.
	An acknowledgement message that begins with a plus sign (+) is 
	considered to be a positive response or &lit(ACK). Conversely 
	the message is regarded as an indication of failure (&lit(NACK))
	if the message begins with a dash (-) character. The lead 
	character and sequence-token may &stress(not) be separted by 
	any whitespace. 
	If the desired number of acknowledgements are not received, 
	the message is written to a local log file as defined by 
	the &lit(LOG_NACKLOG) cartulary variable. 
&space
&subcat	Non-broadcasting Mode
	If the &lit(LOG_ACK_NEEDED) cartulary file variable is set to 
	zero, or a negative value, then broadcasting mode is turned off.
	When in non-broadcast mode, &this will write the message to the 
	log file on the local machine and then return.

&space
&subcat Single Point 'Broadcasting'
	For isolated hosts (hosts that do not belong directly to a cluster,
	and/or satellite hosts)
	sending log messages into the cluster can be accomplished by 
	supplying the 'broadcast' address via a cartulary variable (NG_LOG_BCAST).
	Typically this address is the word &lit(localhost) which causes 
	a UDP/IP message to be sent to the local log daemon (ng_logd) 
	which will relay the log message to the cluster and the log 
	message will be broadcast to all nodes on the cluster. 
&space
	When the broadcast address is supplied in this manner, &this
	does not attempt to obtain the real UDP broadcast address from the 
	interface, and log messages are sent directly to the address supplied.
	Log messages are always written to the local log file as a backup. 
	
	

&space
&subcat	Process Termination	
	Under normal circumstanses both functions will only log occurances
	where the desired number of acknowledgements is not received 
	for a message during the timeout period. However, the process 
	will be terminated if the message being broadcast to the 
	log daemon is equal to or of higher priority than the priority 
	level defined by the cartulary file variable &lit(LOG_ABORT).
	By default this value is &lit(-1) which prevents these routines 
	from terminating the process. 

&subcat	Configuration Variables
	The following is a list of variables that are used by these 
	functions:
&begterms
&term	LOG_ABORT : Defines the abort message priority.
	&ital(Ng_log) and &ital(ng_alog) will abort when 
	the number of required acknowledgements for a message of the indicated,
	or higher priority, is not received. If this variable is not 
	defined the default is -1 which turns off the abort logic.
&space
&term	LOG_ACK_NEEDED : Specifies the number of positive acknowledgements
	that are waited for and implies that broadcast mode is enabled. 
	If this cartulary file parameter is not
	specified, then 3 is assumed (also implying that broadcast mode
	is enabled). If this value is set to zero, or a
	negative value, then broadcast mode is disabled and the message is 
	written to the indicated log file on the local host. 
&space
&term	LOG_IF_NAME : The name of the interface that is used for 
	broadcast messages. If this cartulary variable is not 
	defined, then a value of &lit(eth0) is used as the default.
&space
&term	LOG_NACKLOG : Defines the file name of the file that should be 
	used to log instances when not enough acks are received during 
	the timeout period. If not defined then the file name
	&lit(/ningaui/site/log/ng_log.nack) is used as a default.
&space
&term	LOG_TIMEOUT : Defines the number of seconds that acknowlegements
	must be received in. If &lit(LOG_TIMEOUT) seconds passes 
	before the required number of positive ackowledgements have 
	been received, then an error state is entered. 
	If this variable is not defined in the cartulary file then
	a default of 20 seconds is used. 

&space
&term	NG_LOG_BCAST : Supplies the IP address of the host that is running 
	a Ningaui log daemon.  When the 'broadcast' address is supplied to 
	&this via this cartulary variable, UDP log messages are sent to 
	this address rather than to the standard UDP broadcast address for 
	the network interface.  
	If this cartulary variable is not defined, then messages are written
	using the broadcast address returned by the interface.  If this 
	variable is set to a host name (including localhost) rather than 
	a true broadcast address, then the &lit(LOG_ACK_NEEDED) variable 
	should be set to 1 to prevent waiting on ack/nack messages that 
	will never be received. 
&endterms

&space
&parms  The following parameters are expected by the &ital(ng_log) function:
&space
&begterms
&term	priority : An integer indicating the message priority. The integer
	must be one of the LOG_ constants defined in the <sys/syslog.h> 
	header file. We prefer the following:
	&lit(LOG_CRIT) (critical condition),
	&lit(LOG_ERR) (error condition),
	&lit(LOG_WARNING) (warning condition),
	&lit(LOG_NOTICE) (normal but signification condition),
	&lit(LOG_INFO) (informational).
&space
&term	fmt : A pointer to a NULL terminated character string containing 
	a &ital(printf) style format string. This string, along with the 
	remaining arguments, is passed to the &ital(vsprintf) function 
	to format the user message. 
&endterms

&space
&return The function is declared as a &ital(void) function and thus no 
	value is returned to the caller. 


&space
&files	/ningaui/site/log/master .br
	/ningaui/site/log/ng_log.nack

&space
&see 	ng_env, ng_log, syslogd(1M), syslog(3), vsprintf(3S)

&space
&mods
&owner(Scott Daniels)
&lgterms
&term	16 July 1997 (sd) : Original code. &break
&term	05 Nov 1997 (sd) : To convert to vargs.
&term   18 Dec 1997 (sd) : To remove all line feeds. (Issue 50)
&term   12 Jan 1999 (sd) : To prevent buffer overruns.
&term 	27 Mar 2001 (sd) : Converted from Gecko
&term	07 Apr 2001 (sd) : Added abort logic.
&term	02 May 2001 (sd) : Added support for non-broadcast mode
&term	23 May 2001 (sd) : To shorten name to just the node portion
&term	25 Sep 2001 (sd) : To always write the message to our local log in addition to broadcast.
&term	26 Dec 2001 (sd) : To add ability to 'broadcast' to a single host via ip address in NG_LOG_BCAST
	Also modified to send the cartulary var name (rather than the real log name) on broadcast 
	messages as the real path might not be the same on each host.
&term	03 Apr 2003 (sd) : corrected a memory leak.
&term	05 Jul 2003 (sd) : Added reinit logic if we dont get enough acks. Should prevent issues when 
	someone mucks with the network causing broadcast messages to fail.
&term	26 Aug 2003 (sd) : Modified to allow a repeater to broadcast a preformatted log message.
&term	20 Sep 2003 (sd) : Fixed a bug in init that was passing a const strint to free in some cases.
&term	11 Feb 2004 (sd) : Added a test to ng_log to ensure priority was >= 0 in addition to the exitsing
	upper bound check.
&term	15 Jul 2004 (sd) : Added free of two buffers if not broadcasting messages.
&term	13 Sep 2004 (sd) : Reordered include files to drop stdio after ast_common.h.
&term	17 Sep 2004 (sd) : Corrected %u now that timestamp is large.
&term	22 Apr 2005 (sd) : Corrected could not get bcast message to contain valid data.
&term	31 Jul 2005 (sd) : To prevent warnings from gcc -Wall flag.
&term	16 Nov 2006 (sd) : Converted sfopen() to ng_sfopen(), and now check return of sfclose().
&term	22 Dec 2006 (sd) : We now indicate a message as truncated if we do chop it.
&term	04 Jan 2007 (sd) : Modified such that the max message size (including header stuff) is not more than
	the UDP payload max. Because we broadcast, we must ensure that the data fits into a single
	UDP message. 
&term	01 Nove 2007 (sd) : Fixed error message to add trailing newline.
&endterms

&scd_end
*/
